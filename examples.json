{
  "antiunify": "(datatype Expr\n  (Num i64)\n  (Var String)\n  (Add Expr Expr))\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n\n;; antiunificaiton returns an expression that could unify with either\n;; of the input expressions\n;; (AU x y) can be considered a placeholder variable\n(function AU (Expr Expr) Expr)\n\n(rewrite (AU x x) x)\n(rewrite\n (AU (Add a b) (Add c d))\n (Add (AU a c) (AU b d)))\n\n(define e1 (Add (Var \"x\") (Add (Num 1) (Num 2))))\n(define e2 (Add (Num 3) (Var \"y\")))\n\n(define au12 (AU e1 e2))\n\n(run 4)\n(check (= au12 (Add (Num 3) (AU (Var \"x\") (Var \"y\")))))\n(extract au12)\n(clear)",
  "array": "; Smtlib theory of arrays\n; https://smtlib.cs.uiowa.edu/theories-ArraysEx.shtml\n; http://smtlib.cs.uiowa.edu/version1/theories/Arrays.smt\n\n(datatype Math\n  (Num i64)\n  (Var String)\n)\n\n\n(datatype Array\n  (Const i64)\n  (AVar String)\n)\n\n(function add (Math Math) Math)\n(function select (Array Math) Math)\n(function store (Array Math Math) Array)\n\n(relation neq (Math Math))\n\n(rule ((neq x y))\n      ((neq y x)))\n\n(rule ((neq x x))\n      ((panic \"query (neq x x) found something equal to itself\")))\n\n\n; injectivity rules take not equal to not equal.\n(rule  ((neq x y) (= (add x z) e))\n       ((neq (add x z) (add y z))))\n(rule  ((= (add x (Num i)) e) (!= i 0))\n       ((neq e x)))\n\n\n(rule ((= (Num a) n1) (= (Num b) n2) (!= a b))\n      ((neq n1 n2)))\n\n; select gets from store\n(rewrite (select (store mem i e) i) e)\n; select passes through wrong index\n(rule ((= (select (store mem i1 e) i2) e1) (neq i1 i2))\n      ((set (select mem i2) e1)))\n; aliasing writes destroy old value\n(rewrite (store (store mem i e1) i e2) (store mem i e2))\n; non-aliasing writes commutes\n(rule ((= (store (store mem i2 e2) i1 e1) mem1) (neq i1 i2))\n      ((set (store (store mem i1 e1) i2 e2) mem1)))\n\n; typical math rules\n(rewrite (add x y) (add y x))\n(rewrite (add (add x y) z) (add x (add y z)))\n(rewrite (add (Num x) (Num y)) (Num (+ x y)))\n\n(define r1 (Var \"r1\"))\n(define r2 (Var \"r2\"))\n(define r3 (Var \"r3\"))\n(define mem1 (AVar \"mem1\"))\n\n(neq r1 r2)\n(neq r2 r3)\n(neq r1 r3)\n(define test1 (select (store mem1 r1 (Num 42)) r1))\n(define test2 (select (store mem1 r1 (Num 42)) (add r1 (Num 17))))\n(define test3 (select (store (store mem1 (add r1 r2) (Num 1)) (add r2 r1) (Num 2)) (add r1 r3)))\n\n(run 4)\n(check (= test1 (Num 42)))\n(check (neq r1 r2))\n(check (neq r1 (add r1 (Num 17))))\n(check (= test2 (select mem1 (add r1 (Num 17)))))\n(check (= test3 (select mem1 (add r1 r3))))\n\n\n\n",
  "bdd": "; Binary Decision Diagrams are if-then-else trees/ compressed tries that hash cons their leaves\n; This is easily expressible in the facilities provided. Everything in egg-smol is automatcally shared\n; and Compression is easily expressible as a rule.\n\n; They are a notion of first class set useful for certain classes of uniformly describable sets.\n; https://en.wikipedia.org/wiki/Binary_decision_diagram\n; https://www.lri.fr/~filliatr/ftp/publis/hash-consing2.pdf Type-Safe Modular Hash-Consing - Section 3.3\n\n(datatype BDD\n    (ITE i64 BDD BDD) ; variables labelled by number\n    (True)\n    (False)\n)\n\n; compress unneeded nodes\n(rewrite (ITE n a a) a)\n\n(function and (BDD BDD) BDD)\n(rewrite (and (False) n) (False))\n(rewrite (and n (False)) (False))\n(rewrite (and (True) x) x)\n(rewrite (and x (True)) x)\n; We use an order where low variables are higher in tree\n; Could go the other way.\n(rewrite (and (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (and a1 (ITE m b1 b2)) (and a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (and (ITE n a1 a2) (ITE m b1 b2))\n    (ITE m (and (ITE n a1 a2) b1) (and (ITE n a1 a2) b2))\n    :when ((> n m))\n)\n(rewrite (and (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (and a1 b1) (and a2 b2))\n)\n\n(define b0 (ITE 0 (True) (False)))\n(define b1 (ITE 1 (True) (False)))\n(define b2 (ITE 2 (True) (False)))\n\n(define b123 (and b2 (and b0 b1)))\n(define b11 (and b1 b1))\n(define b12 (and b1 b2))\n(run 5)\n(extract b11)\n(extract b12)\n(extract b123)\n(check (= (and (ITE 1 (True) (False)) (ITE 2 (True) (False)))\n       (ITE 1 (ITE 2 (True) (False)) (False)))\n)\n;(check (= b123 (ITE 3 ()))\n\n(function or (BDD BDD) BDD)\n(rewrite (or (True) n) (True))\n(rewrite (or n (True)) (True))\n(rewrite (or (False) x) x)\n(rewrite (or x (False)) x)\n(rewrite (or (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (or a1 (ITE m b1 b2)) (or a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (or (ITE n a1 a2) (ITE m b1 b2))\n    (ITE m (or (ITE n a1 a2) b1) (or (ITE n a1 a2) b2))\n    :when ((> n m))\n)\n(rewrite (or (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (or a1 b1) (or a2 b2))\n)\n\n(define or121 (or b1 (or b2 b1)))\n(run 5)\n(extract or121)\n\n(function not (BDD) BDD)\n(rewrite (not (True)) (False))\n(rewrite (not (False)) (True))\n(rewrite (not (ITE n a1 a2)) (not (ITE n (not a1) (not a2))))\n\n(function xor (BDD BDD) BDD)\n(rewrite (xor (True) n) (not n))\n(rewrite (xor n (True)) (not n))\n(rewrite (xor (False) x) x)\n(rewrite (xor x (False)) x)\n(rewrite (xor (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (xor a1 (ITE m b1 b2)) (or a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (xor (ITE n a1 a2) (ITE m b1 b2))\n    (ITE m (xor (ITE n a1 a2) b1) (or (ITE n a1 a2) b2))\n    :when ((> n m))\n)\n(rewrite (xor (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (xor a1 b1) (xor a2 b2))\n)\n\n\n",
  "bitwise": "(check (= 0 (& 10 0)))\n(check (= 8 (& 8 10)))\n(check (= 10 (| 8 10)))\n(check (= 2 (^ 8 10)))\n(check (= 8 (<< 1 3)))\n(check (= 1 (>> 8 3)))\n(check (= 2 (% 8 3)))\n(check (= 2 (/ 8 3)))\n(check (= -1 (not-i64 0)))\n\n; bitsets\n;(function bs-union (i64 i64) i64)\n;(rewrite (bs-union a b) (| a b))\n\n;(function bs-inter (i64 i64) i64)\n;(rewrite (bs-inter a b) (& a b))\n\n;(function bs-comp (i64) i64)\n;(rewrite (bs-comp a) (bvnot a))\n\n; singleton set\n;(function bs-sing (i64) i64)\n;(rewrite (bs-sing a) (1 << a))\n\n;(function bs-insert (i64 i64) i64)\n;(rewrite (bs-insert s x) (| s (1 << a))\n\n;(function bs-diff (i64 i64) i64)\n;(rewrite (bs-diff a b) (^ a (bs-inter a b))\n\n;(define bs-empty 0)\n\n;(define bs-subset (i64 i64) bool)\n;(rewrite (bs-subset x y) (is-zero (bs-diff x y)))\n\n;(define bs-is-elem (i64 i64) bool)\n;(rewrite (bs-is-elem s x) (not (is-zero (bs-inter s (sing x)))))\n",
  "delete": "(function foo (i64) i64)\n(set (foo 1) 7)\n(check (= (foo 1) 7))\n(delete (foo 1))\n(rule ((= x (foo 1))) ((panic \"foo 1 was there!\")))\n(run 1)",
  "eqsat-basic": "(datatype Math\n  (Num i64)\n  (Var String)\n  (Add Math Math)\n  (Mul Math Math))\n\n;; expr1 = 2 * (x + 3)\n(define expr1 (Mul (Num 2) (Add (Var \"x\") (Num 3)))) \n;; expr2 = 6 + 2 * x\n(define expr2 (Add (Num 6) (Mul (Num 2) (Var \"x\"))))\n\n\n;; (rule ((= __root (Add a b)))\n;;       ((union __root (Add b a)))\n(rewrite (Add a b)\n         (Add b a))\n(rewrite (Mul a (Add b c))\n         (Add (Mul a b) (Mul a c)))\n(rewrite (Add (Num a) (Num b)) \n         (Num (+ a b)))\n(rewrite (Mul (Num a) (Num b))\n         (Num (* a b)))\n\n(run 10)\n(check (= expr1 expr2))",
  "eqsolve": "(datatype Expr\n  (Add Expr Expr)\n  (Neg Expr)\n  (Num i64)\n  (Mul Expr Expr)\n  (Var String)\n)\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Add x y) z) (Add x (Add y z)))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n(rule ((= (Add x y) z))\n      ((union (Add z (Neg y)) x)))\n(rewrite (Neg (Neg x)) x)\n(rewrite (Neg (Num n)) (Num (- 0 n)))\n\n(rule ((= x (Var v))) ((union (Mul (Num 1) x) x)))\n(rule ((= x (Add x1 x2))) ((union (Mul (Num 1) x) x)))\n(rewrite (Add (Mul y x) (Mul z x)) (Mul (Add y z) x))\n(rewrite (Mul x y) (Mul y x))\n(rule ((= (Mul (Num x) y) (Num z))\n       (= (% z x) 0))\n      ((union y (Num (/ z x)))))\n\n; system 1: x + 2 = 7\n(set (Add (Var \"x\") (Num 2)) (Num 7))\n; system 2: z + y = 6, 2z = y\n(set (Add (Var \"z\") (Var \"y\")) (Num 6))\n(set (Add (Var \"z\") (Var \"z\")) (Var \"y\"))\n\n(run 5)\n(extract (Var \"x\"))\n(extract (Var \"y\"))\n(extract (Var \"z\"))\n(check (= (Var \"z\") (Add (Num 6) (Neg (Var \"y\")))))\n(check (= (Var \"y\") (Add (Add (Num 6) (Neg (Var \"y\"))) (Add (Num 6) (Neg (Var \"y\"))))))\n(check (= (Var \"y\") (Add (Add (Num 12) (Neg (Var \"y\"))) (Neg (Var \"y\")))))\n(check (= (Add (Var \"y\") (Var \"y\")) \n          (Add (Num 12) (Neg (Var \"y\")))))\n(check (= (Add (Add (Var \"y\") (Var \"y\")) (Var \"y\"))\n          (Num 12)))\n(check (= (Add (Mul (Num 2) (Var \"y\")) (Var \"y\"))\n          (Num 12)))\n(check (= (Mul (Num 3) (Var \"y\"))\n          (Num 12)))\n",
  "extraction-cost": "(datatype Expr\n  (Num i64 :cost 5))\n\n(define x (Num 1) :cost 10)\n(define y (Num 2) :cost 1)\n\n(extract x) ;; (Num 1)\n(extract y) ;; (y)",
  "fibonacci-demand": "(datatype Expr \n  (Num i64)\n  (Add Expr Expr))\n\n(function Fib (i64) Expr)\n\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rule ((= f (Fib x))\n       (> x 1))\n      ((set (Fib x) (Add (Fib (- x 1)) (Fib (- x 2))))))\n\n(set (Fib 0) (Num 0))\n(set (Fib 1) (Num 1))\n\n(define f7 (Fib 7))\n(run 14)\n(extract f7)\n(check (= f7 (Num 13)))\n       \n ",
  "fibonacci": "(function fib (i64) i64)\n(set (fib 0) 0)\n(set (fib 1) 1)\n\n(rule ((= f0 (fib x))\n       (= f1 (fib (+ x 1))))\n      ((set (fib (+ x 2)) (+ f0 f1))))\n\n(run 7)\n\n(check (= (fib 7) 13))",
  "herbie": ";; Implements part of the simplification layer of herbie in egg-smol\ud83e\udee1\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Datatypes\n\n(datatype Math\n  ; Ground terms\n  (Num Rational)\n  (Var String)\n\n  ; Custom ops\n  (Const String)\n  (Unary String Math)\n  ; unneeded for now\n  ; (Binary String Math Math)\n\n  ; Constant-folding ops\n  (Add Math Math)\n  (Sub Math Math)\n  (Mul Math Math)\n  (Div Math Math)\n  (Pow Math Math)\n  (Neg Math)\n  (Sqrt Math)\n  (Cbrt Math) ; cube root\n  (Fabs Math)\n  (Ceil Math)\n  (Floor Math)\n  (Round Math)\n  (Log Math))\n\n(define r-zero (rational 0 1))\n(define r-one  (rational 1 1))\n(define r-two  (rational 2 1))\n(define zero (Num r-zero))\n(define one  (Num r-one))\n(define two  (Num r-two))\n(define three (Num (rational 3 1)))\n(define neg-one (Neg one))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Analyses\n;; --------\n;; This example has three analyses:\n;; an interval analysis consisting of a hi and lo component\n;; and a non-zero analysis.\n;; The non-zero analysis is built off the interval analysis (in order to prove\n;; that rewrites are sound, even if some parts of an expr can't be const-evaled)\n\n; TODO: unbounded intervals?\n(function hi (Math) Rational :merge (min old new))\n(function lo (Math) Rational :merge (max old new))\n(relation non-zero (Math))\n\n;; First, constant folding!\n;; We don't need an explicit constant folding analysis, we can just union\n;; with nums when we can\n\n; Cases\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Sub (Num a) (Num b)) (Num (- a b)))\n(rewrite (Mul (Num a) (Num b)) (Num (* a b)))\n(rewrite (Div (Num a) denom) (Num (/ a b)) :when ((= denom (Num b)) (non-zero denom)))\n(rewrite (Pow (Num a) (Num b)) (Num res) :when ((= res (pow a b))))\n(rewrite (Neg (Num a)) (Num (neg a)))\n;; TODO unimplemented\n;; (rewrite (Sqrt (Num a)) (Num res) :when ((= res (sqrt a))))\n;; (rewrite (Cbrt (Num a)) (Num res) :when ((= res (cbrt a))))\n(rewrite (Fabs (Num a)) (Num (abs a)))\n(rewrite (Ceil (Num a)) (Num (ceil a)))\n(rewrite (Floor (Num a)) (Num (floor a)))\n(rewrite (Round (Num a)) (Num (round a)))\n(rewrite (Log (Num a)) (Num res) :when ((= res (log a))))\n\n;; To check if something is zero, we check that zero is not contained in the\n;; interval. There are two possible (overlapping!) cases:\n;; - There exists a lo interval, in which case it must be larger than 0\n;; - There exists a hi interval, in which case it must be smaller than 0\n;; This assumes that intervals are well-formed: lo <= hi at all times.\n(rule ((= l (lo e))\n       (> l r-zero))\n      ((non-zero e)))\n(rule ((= h (hi e))\n       (< h r-zero))\n      ((non-zero e)))\n\n(rule ((= e (Num ve)))\n      ((set (lo e) ve)\n       (set (hi e) ve)))\n\n;; The interval analyses are similar to the constant-folding analysis,\n;; except we have to take the lower/upper bound of the results we get\n(rule ((= e (Add a b))\n       (= la (lo a))\n       (= lb (lo b)))\n      ((set (lo e) (+ la lb))))\n(rule ((= e (Add a b))\n       (= ha (hi a))\n       (= hb (hi b)))\n      ((set (hi e) (+ ha hb))))\n      \n(rule ((= e (Sub a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (- la lb) (- la hb))\n               (min (- ha lb) (- ha hb))))\n       (set (hi e) \n          (max (max (- la lb) (- la hb))\n               (max (- ha lb) (- ha hb))))))\n\n(rule ((= e (Mul a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (* la lb) (* la hb))\n               (min (* ha lb) (* ha hb))))\n       (set (hi e) \n          (max (max (* la lb) (* la hb))\n               (max (* ha lb) (* ha hb))))))\n\n(rule ((= e (Div a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (/ la lb) (/ la hb))\n               (min (/ ha lb) (/ ha hb))))\n       (set (hi e) \n          (max (max (/ la lb) (/ la hb))\n               (max (/ ha lb) (/ ha hb))))))\n\n; TODO: Pow\n\n(rule ((= e (Neg a))\n       (= la (lo a))\n       (= ha (hi a)))\n      ((set (lo e) (neg ha))\n       (set (hi e) (neg la))))\n\n; TODO: Sqrt\n; TODO: Cbrt\n\n(rule ((= e (Fabs a))\n       (= la (lo a))\n       (= ha (hi a)))\n      ((set (lo e) (min (abs la) (abs ha)))\n       (set (hi e) (max (abs la) (abs ha)))))\n\n(rule ((= e (Ceil a))\n       (= la (lo a)))\n      ((set (lo e) (ceil la))))\n(rule ((= e (Ceil a))\n       (= ha (hi a)))\n      ((set (hi e) (ceil ha))))\n\n(rule ((= e (Floor a))\n       (= la (lo a)))\n      ((set (lo e) (floor la))))\n(rule ((= e (Floor a))\n       (= ha (hi a)))\n      ((set (hi e) (floor ha))))\n\n(rule ((= e (Round a))\n       (= la (lo a)))\n      ((set (lo e) (round la))))\n(rule ((= e (Round a))\n       (= ha (hi a)))\n      ((set (hi e) (round ha))))\n\n; TODO: Log\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Rewrites\n;; --------\n;; These rewrites were compiled from src/syntax/rules.rkt in the herbie repo,\n;; using all rewrites in the `simplify` rewrite group.\n\n;; Commutativity\n(rewrite (Add a b) (Add b a))\n(rewrite (Mul a b) (Mul b a))\n\n;; Associativity\n(rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rewrite (Add (Add a b) c) (Add a (Add b c)))\n(rewrite (Add a (Sub b c)) (Sub (Add a b) c))\n(rewrite (Add (Sub a b) c) (Sub a (Sub b c)))\n(rewrite (Sub a (Add b c)) (Sub (Sub a b) c))\n(rewrite (Sub (Add a b) c) (Add a (Sub b c)))\n(rewrite (Sub (Sub a b) c) (Sub a (Add b c)))\n(rewrite (Sub a (Sub b c)) (Add (Sub a b) c))\n(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))\n(rewrite (Mul (Mul a b) c) (Mul a (Mul b c)))\n(rewrite (Mul a (Div b c)) (Div (Mul a b) c))\n(rewrite (Mul (Div a b) c) (Div (Mul a c) b))\n(rewrite (Div a (Mul b c)) (Div (Div a b) c))\n(rewrite (Div (Mul b c) a) (Div b (Div a c)) :when ((non-zero c)))\n(rewrite (Div a (Div b c)) (Mul (Div a b) c) :when ((non-zero c)))\n(rewrite (Div (Div b c) a) (Div b (Mul a c)) :when ((non-zero a)))\n\n;; Counting\n(rewrite (Add x x) (Mul two x))\n\n;; Distributivity\n(rewrite (Mul a (Add b c))         (Add (Mul a b) (Mul a c)))\n(rewrite (Mul a (Add b c))         (Add (Mul b a) (Mul c a)))\n(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))\n(rewrite (Sub (Mul a b) (Mul a c)) (Mul a (Sub b c)))\n(rewrite (Add (Mul b a) (Mul c a)) (Mul a (Add b c)))\n(rewrite (Sub (Mul b a) (Mul c a)) (Mul a (Sub b c)))\n(rewrite (Add (Mul b a) a)         (Mul (Add b one) a))\n(rewrite (Add a (Mul c a))         (Mul (Add c one) a))\n\n(rewrite (Neg (Mul a b))       (Mul (Neg a) b))\n(rewrite (Neg (Mul a b))       (Mul a (Neg b)))\n(rewrite (Mul (Neg a) b)       (Neg (Mul a b)))\n(rewrite (Mul a (Neg b))       (Neg (Mul a b)))\n(rewrite (Neg (Add a b))       (Add (Neg a) (Neg b)))\n(rewrite (Add (Neg a) (Neg b)) (Neg (Add a b)))\n(rewrite (Div (Neg a) b)       (Neg (Div a b)))\n(rewrite (Neg (Div a b))       (Div (Neg a) b))\n\n(rewrite (Sub a (Mul (Neg b) c)) (Add a (Mul b c)))\n(rewrite (Sub a (Mul b c))       (Add a (Mul (Neg b) c)))\n\n;; Difference of squares\n(rewrite (Mul (Mul a b) (Mul a b))                           (Mul (Mul a a) (Mul b b)))\n(rewrite (Mul (Mul a a) (Mul b b))                           (Mul (Mul a b) (Mul a b)))\n(rewrite (Sub (Mul a a) (Mul b b))                           (Mul (Add a b) (Sub a b)))\n(rewrite (Sub (Mul a a) one)                (Mul (Add a one) (Sub a one)))\n(rewrite (Add (Mul a a) (Neg one))          (Mul (Add a one) (Sub a one)))\n(rewrite (Pow a b) (Mul (Pow a (Div b two)) (Pow a (Div b two))))\n(rewrite (Mul (Pow a b) (Pow a b))                           (Pow a (Mul two b)))\n\n;; Identity\n;; This isn't subsumed by const folding since this can return results\n;; even if we can't evaluate a precise value for x\n(rewrite (Div one (Div one x))\n         x\n         :when ((non-zero x)))\n(rewrite (Mul x (Div one x))\n         one\n         :when ((non-zero x)))\n(rewrite (Mul (Div one x) x)\n         one\n         :when ((non-zero x)))\n\n(rewrite (Sub x x) zero)\n(rewrite (Div x x) one\n         :when ((non-zero x)))\n(rewrite (Div zero x) zero\n         :when ((non-zero x)))\n(rewrite (Mul zero x) zero)\n(rewrite (Mul x zero) zero)\n\n(rewrite (Add zero x) x)\n(rewrite (Add x zero) x)\n(rewrite (Sub zero x) (Neg x))\n(rewrite (Sub x zero) x)\n(rewrite (Neg (Neg x)) x)\n(rewrite (Mul one x) x)\n(rewrite (Mul x one) x)\n(rewrite (Div x one) x)\n(rewrite (Mul neg-one x) (Neg x))\n \n(rewrite (Sub a b) (Add a (Neg b)))\n(rewrite (Add a (Neg b)) (Sub a b))\n(rewrite (Neg x) (Sub zero x))\n(rewrite (Neg x) (Mul neg-one x))\n\n(rewrite (Div x y) (Mul x (Div one y)))\n(rewrite (Mul x (Div one y)) (Div x y))\n(rewrite (Div x y) (Div one (Div y x))\n  :when ((non-zero x)\n         (non-zero y)))\n\n; FIXME: this rule can't be expressed in its full generality;\n;        we can't express the general rule x -> 1/x since\n;        we can't quantify over Math yet\n;        for now we just apply it to vars\n;        it's also p slow lmao\n(rewrite (Var x) (Mul one (Var x)))\n\n;; Fractions\n(rewrite (Div (Sub a b) c)         (Sub (Div a c) (Div b c)))\n(rewrite (Div (Mul a b) (Mul c d)) (Mul (Div a c) (Div b d)))\n\n;; Square root\n(rewrite (Mul (Sqrt x) (Sqrt x)) x)\n(rewrite (Sqrt (Mul x x)) (Fabs x))\n\n(rewrite (Mul (Neg x) (Neg x)) (Mul x x))\n(rewrite (Mul (Fabs x) (Fabs x)) (Mul x x))\n\n;; Absolute values\n(rewrite (Fabs (Fabs x)) (Fabs x))\n(rewrite (Fabs (Sub a b)) (Fabs (Sub b a)))\n(rewrite (Fabs (Neg x)) (Fabs x))\n(rewrite (Fabs (Mul x x)) (Mul x x))\n(rewrite (Fabs (Mul a b)) (Mul (Fabs a) (Fabs b)))\n(rewrite (Fabs (Div a b)) (Div (Fabs a) (Fabs b)))\n\n;; Cube root\n(rewrite (Pow (Cbrt x) three)    x)\n(rewrite (Cbrt (Pow x three))    x)\n(rewrite (Mul (Mul (Cbrt x) (Cbrt x)) (Cbrt x)) x)\n(rewrite (Mul (Cbrt x) (Mul (Cbrt x) (Cbrt x))) x)\n(rewrite (Pow (Neg x) three)     (Neg (Pow x three)))\n\n(rewrite (Pow (Mul x y) three)\n         (Mul (Pow x three) (Pow y three)))\n(rewrite (Pow (Div x y) three)\n         (Div (Pow x three) (Pow y three)))\n \n(rewrite (Pow x three) (Mul x (Mul x x)))\n; FIXME: this rewrite is slow and has the potential to blow up the egraph\n;        this is bc this rule and the second-to-last difference of squares rule\n;        have some cyclic behavior goin on\n;        the last identity rule compounds this behavior\n(rewrite (Mul x (Mul x x)) (Pow x three))\n\n;; Exponentials\n(rewrite (Unary \"exp\" (Log x)) x)\n(rewrite (Log (Unary \"exp\" x)) x)\n\n(rewrite (Unary \"exp\" zero) one)\n(rewrite (Unary \"exp\" one) (Const \"E\"))\n;; (rewrite one               (Unary \"exp\" zero))\n(rewrite (Const \"E\")       (Unary \"exp\" one))\n\n(rewrite (Unary \"exp\" (Add a b)) (Mul (Unary \"exp\" a) (Unary \"exp\" b)))\n(rewrite (Unary \"exp\" (Sub a b)) (Div (Unary \"exp\" a) (Unary \"exp\" b)))\n(rewrite (Unary \"exp\" (Neg a))   (Div one (Unary \"exp\" a)))\n\n(rewrite (Mul (Unary \"exp\" a) (Unary \"exp\" b))      (Unary \"exp\" (Add a b)))\n(rewrite (Div one (Unary \"exp\" a)) (Unary \"exp\" (Neg a)))\n(rewrite (Div (Unary \"exp\" a) (Unary \"exp\" b))      (Unary \"exp\" (Sub a b)))\n(rewrite (Unary \"exp\" (Mul a b))                    (Pow (Unary \"exp\" a) b))\n(rewrite (Unary \"exp\" (Div a two)) (Sqrt (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Div a three)) (Cbrt (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Mul a two)) (Mul (Unary \"exp\" a) (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Mul a three)) (Pow (Unary \"exp\" a) three))\n\n;; Powers\n(rewrite (Pow a neg-one) (Div one a))\n(rewrite (Pow a one) a)\n\n; 0^0 is undefined\n(rewrite (Pow a zero) one :when ((non-zero a)))\n(rewrite (Pow one a) one)\n\n(rewrite (Unary \"Exp\" (Mul (Log a) b)) (Pow a b))\n(rewrite (Mul (Pow a b) a) (Pow a (Add b one)))\n(rewrite (Pow a (Num (rational 1 2))) (Sqrt a))\n(rewrite (Pow a two) (Mul a a))\n(rewrite (Pow a (Num (rational 1 3))) (Cbrt a))\n(rewrite (Pow a three) (Mul (Mul a a) a))\n\n; 0^0 is undefined\n(rewrite (Pow zero a) zero :when ((non-zero a)))\n\n;; Logarithms\n(rewrite (Log (Mul a b)) (Add (Log a) (Log b)))\n(rewrite (Log (Div a b)) (Sub (Log a) (Log b)))\n(rewrite (Log (Div one a)) (Neg (Log a)))\n(rewrite (Log (Pow a b)) (Mul b (Log a)))\n(rewrite (Log (Const \"E\")) one)\n\n;; Trigonometry\n(rewrite (Add (Mul (Unary \"cos\" a) (Unary \"cos\" a)) (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n         one)\n(rewrite (Sub one (Mul (Unary \"cos\" a) (Unary \"cos\" a)))\n         (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n(rewrite (Sub one (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n         (Mul (Unary \"cos\" a) (Unary \"cos\" a)))\n(rewrite (Add (Mul (Unary \"cos\" a) (Unary \"cos\" a)) (Num (rational -1 1))) \n         (Neg (Mul (Unary \"sin\" a) (Unary \"sin\" a))))\n(rewrite (Add (Mul (Unary \"sin\" a) (Unary \"sin\" a)) (Num (rational -1 1))) \n         (Neg (Mul (Unary \"cos\" a) (Unary \"cos\" a))))\n(rewrite (Sub (Mul (Unary \"cos\" a) (Unary \"cos\" a)) one)  \n         (Neg (Mul (Unary \"sin\" a) (Unary \"sin\" a))))\n(rewrite (Sub (Mul (Unary \"sin\" a) (Unary \"sin\" a)) one)  \n         (Neg (Mul (Unary \"cos\" a) (Unary \"cos\" a))))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Num (rational 1 2)))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         (Div (Sqrt two) two))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") three))       \n         (Div (Sqrt three) two))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") two))       \n         one)\n(rewrite (Unary \"sin\" (Const \"PI\"))             \n         zero)\n(rewrite (Unary \"sin\" (Add x (Const \"PI\")))       \n         (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"sin\" (Add x (Div (Const \"PI\") two))) \n         (Unary \"cos\" x))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Div (Sqrt three) two))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         (Div (Sqrt two) two))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") three))       \n         (Num (rational 1 2)))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") two))       \n         zero)\n(rewrite (Unary \"cos\" (Const \"PI\"))             \n         (Num (rational -1 1)))\n(rewrite (Unary \"cos\" (Add x (Const \"PI\")))       \n         (Neg (Unary \"cos\" x)))\n(rewrite (Unary \"cos\" (Add x (Div (Const \"PI\") two))) \n         (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"tan\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Div one (Sqrt three)))\n(rewrite (Unary \"tan\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         one)\n(rewrite (Unary \"tan\" (Div (Const \"PI\") three))       \n         (Sqrt three))\n(rewrite (Unary \"tan\" (Const \"PI\"))             \n         zero)\n(rewrite (Unary \"tan\" (Add x (Const \"PI\")))       \n         (Unary \"tan\" x))\n(rewrite (Unary \"tan\" (Add x (Div (Const \"PI\") two))) \n         (Div neg-one (Unary \"tan\" x)))\n(rewrite (Div (Unary \"sin\" a) (Add one (Unary \"cos\" a)))    \n         (Unary \"tan\" (Div a two)))\n(rewrite (Div (Neg (Unary \"sin\" a)) (Add one (Unary \"cos\" a)))\n         (Unary \"tan\" (Div (Neg a) two)))\n(rewrite (Div (Sub one (Unary \"cos\" a)) (Unary \"sin\" a))    \n         (Unary \"tan\" (Div a two)))\n(rewrite (Div (Sub one (Unary \"cos\" a)) (Neg (Unary \"sin\" a)))\n         (Unary \"tan\" (Div (Neg a) two)))\n(rewrite (Div (Add (Unary \"sin\" a) (Unary \"sin\" b)) (Add (Unary \"cos\" a) (Unary \"cos\" b)))\n         (Unary \"tan\" (Div (Add a b) two)))\n(rewrite (Div (Sub (Unary \"sin\" a) (Unary \"sin\" b)) (Add (Unary \"cos\" a) (Unary \"cos\" b)))\n         (Unary \"tan\" (Div (Sub a b) two)))\n\n(rewrite (Unary \"sin\" zero) zero)\n(rewrite (Unary \"cos\" zero) one)\n(rewrite (Unary \"tan\" zero) zero)\n\n(rewrite (Unary \"sin\" (Neg x)) (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"cos\" (Neg x)) (Unary \"cos\" x))\n(rewrite (Unary \"tan\" (Neg x)) (Neg (Unary \"cos\" x)))\n\n; Hyperbolics\n(rewrite (Unary \"sinh\" x) (Div (Sub (Unary \"exp\" x) (Unary \"exp\" (Neg x))) two))\n(rewrite (Unary \"cosh\" x) (Div (Add (Unary \"exp\" x) (Unary \"exp\" (Neg x))) two))\n(rewrite (Unary \"tanh\" x) (Div (Sub (Unary \"exp\" x) (Unary \"exp\" (Neg x))) (Add (Unary \"exp\" x) (Unary \"exp\" (Neg x)))))\n(rewrite (Unary \"tanh\" x) (Div (Sub (Unary \"exp\" (Mul two x)) one) (Add (Unary \"exp\" (Mul two x)) one)))\n(rewrite (Unary \"tanh\" x) (Div (Sub one (Unary \"exp\" (Mul (Num (rational -2 1)) x))) (Add one (Unary \"exp\" (Mul (Num (rational -2 1)) x)))))\n(rewrite (Sub (Mul (Unary \"cosh\" x) (Unary \"cosh\" x)) (Mul (Unary \"sinh\" x) (Unary \"sinh\" x))) one)\n(rewrite (Add (Unary \"cosh\" x) (Unary \"sinh\" x)) (Unary \"exp\" x))\n(rewrite (Sub (Unary \"cosh\" x) (Unary \"sinh\" x)) (Unary \"exp\" (Neg x)))\n\n;; Unimplemented: misc. rewrites (conditionals, specialized numerical fns)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Testing\n;; -------\n;; In actuality, herbie would be responsible for plugging exprs in here.\n;; For our purposes, we take some test cases from herbie\n;; (src/core/simplify.rkt)\n\n(push)\n(define e (Add one zero))\n(run 1)\n(check (= e one))\n(pop)\n\n(push)\n(define five (Num (rational 5 1)))\n(define six (Num (rational 6 1)))\n(define e (Add one five))\n(run 1)\n(check (= e six))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(define e (Add x zero))\n(run 1)\n(check (= e x))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(define e (Sub x zero))\n(run 1)\n(check (= e x))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(define e (Mul x one))\n(run 1)\n(check (= e x))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(define e (Div x one))\n(run 1)\n(check (= e x))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(define e (Sub (Mul one x) (Mul (Add x one) one)))\n(run 3)\n(check (= e (Num (rational -1 1))))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(define e (Sub (Add x one) x))\n(run 4)\n(check (= e one))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(define e (Sub (Add x one) one))\n(run 4)\n(check (= e x))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(set (lo x) r-one)\n(define e (Div (Mul x three) x))\n(run 3)\n(check (= e three))\n(pop)\n\n(push)\n(define x (Var \"x\"))\n(define e (Sub (Mul (Sqrt (Add x one)) (Sqrt (Add x one))) (Mul (Sqrt x) (Sqrt x))))\n(run 5)\n(check (= one e))\n(pop)\n\n(push)\n(define e (Add (Num (rational 1 5)) (Num (rational 3 10))))\n(run 1)\n(check (= e (Num (rational 1 2))))\n(pop)\n\n(push)\n(define e (Unary \"cos\" (Const \"PI\")))\n(run 1)\n(check (= e (Num (rational -1 1))))\n(pop)\n\n(push)\n(define sqrt5 (Sqrt (Num (rational 5 1))))\n(define e\n  (Div one (Sub (Div (Add one sqrt5) two) (Div (Sub one sqrt5) two))))\n(define tgt (Div one sqrt5))\n(run 6)\n(check (= e tgt))\n; TODO: we can't just do (= e (Div one sqrt5)) cause that doesn't work\n;       unless we add the following lines to check_with after evaluating\n;       the exprs into values:\n;\n;       self.rebuild();\n;       let values: Vec<Value> = values\n;           .into_iter()\n;           .map(|v| self.bad_find_value(v))\n;           .collect::<Vec<_>>();\n;\n;       i have no idea if that's correct to do so i didn't do it\n(pop)",
  "interval": "(datatype Math\n  (Num Rational)\n  (Var String)\n  (Mul Math Math))\n\n(function hi (Math) Rational :merge (min old new))\n(function lo (Math) Rational :merge (max old new))\n\n(rule ((= mul (Mul a b)))\n      ((set (lo mul) \n          (min (min (* (lo a) (lo b)) (* (lo a) (hi b)))\n               (min (* (hi a) (lo b)) (* (hi a) (hi b)))))))\n\n(define x (Var \"x\"))\n(define e (Mul x x))\n\n(set (lo x) (rational -10 1))\n(set (hi x) (rational 10 1))\n\n(run 1)\n\n(check (= (lo e) (rational -100 1)))\n\n(rule ((= mul (Mul a a)))\n      ((set (lo mul) (* (lo a) (lo a)))))\n\n(run 1)\n(check (= (lo e) (rational 100 1)))\n\n;; testing extraction of rationals\n(extract (lo e))\n",
  "lambda": ";; NOTE: This file contains several unsafe operations\n(datatype Value (True) (False) (Num i64))\n(datatype Var)\n(datatype Term\n    (Val Value)\n    (Var Var)\n    (Add Term Term)\n    (Eq Term Term)\n    (App Term Term)\n    (Lam Var Term)\n    (Let Var Term Term)\n    (Fix Var Term)\n    (If Term Term Term))\n(function V (String) Var) \n(function From (Term) Var)\n\n; All free variables are free,\n; but some free variables are more free than others\n; Freer variables will only contain variables\n; that will affect the evaluation\n; of the corresponding term\n; e.g., x is free in x - x, but not freer in x - x\n(sort StringSet (Map Var i64))\n(function freer (Term) StringSet :merge (set-intersect old new))\n(rule ((= e (Val v)))\n      ((set (freer e) (empty))))\n(rule ((= e (Var v)))\n      ((set (freer e) (insert (empty) v 1))))\n(rule ((= e (Add e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Eq e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (App e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Lam var body))\n       (= (freer body) fv))\n      ((set (freer e) (map-remove fv var))))\n(rule ((= e (Let var e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union (map-remove fv1 var) fv2))))\n(rule ((= e (Fix var body))\n       (= (freer body) fv))\n      ((set (freer e) (map-remove fv var))))\n(rule ((= e (If c e1 e2))\n       (= (freer c) fv1)\n       (= (freer e1) fv2)\n       (= (freer e2) fv3))\n      ((set (freer e) (set-union fv1 (set-union fv2 fv3)))))\n\n;; START evals-to\n(function evals-to (Term) Value)\n\n(rule ((= e (Val val)))\n      ((union (evals-to e) val)))\n(rule ((= e (Add a b))\n       (= (Num va) (evals-to a))\n       (= (Num vb) (evals-to b)))\n      ((union (evals-to e) (Num (+ va vb)))))\n(rule ((= e (Eq a b))\n       (= (evals-to b) (evals-to a)))\n      ((union (evals-to e) (True))))\n(rule ((= e (Eq a b))\n       (= va (evals-to a))\n       (= vb (evals-to b))\n       (!= va vb)) ; TODO: if true and false are non-mergeable datatype, \n                   ; we should be able to do != over it\n      ((union (evals-to e) (False))))\n(rule ((= v (evals-to e)))\n      ((union e (Val v))))\n;; END evals-to\n\n; if-true\n(rewrite (If (Val (True)) then else) then)\n; if-false\n(rewrite (If (Val (False)) then else) else)\n; if-elim\n(rule ((= term (If (Eq (Var x) e) then else)))\n      ((Let x e then)\n       (Let x e else)))\n(rewrite (If (Eq (Var x) e) then else) else\n    :when ((= (Let x e then) (Let x e else))))\n\n; add-comm\n(rewrite (Add a b) (Add b a))\n; add-assoc\n(rewrite (Add (Add a b) c) (Add a (Add b c)))\n; eq-comm\n(rewrite (Eq a b) (Eq b a))\n\n; fix\n(rewrite (Fix v e) (Let v (Fix v e) e))\n; beta\n(rewrite (App (Lam v body) e) (Let v e body))\n; let-app\n(rewrite (Let v e (App a b)) (App (Let v e a) (Let v e b)))\n; let-add\n(rewrite (Let v e (Add a b)) (Add (Let v e a) (Let v e b)))\n; let-eq\n(rewrite (Let v e (Eq a b)) (Eq (Let v e a) (Let v e b)))\n; let-const\n(rewrite (Let v e c) c :when ((= const (evals-to c))))\n; let-if\n(rewrite (Let v e (If cond then else)) \n         (If (Let v e cond) (Let v e then) (Let v e else)))\n; let-var-same\n(rewrite (Let v1 e (Var v1)) e)\n; let-var-diff\n(rewrite (Let v1 e (Var v2)) (Var v2) :when ((!= v1 v2)))\n; let-lam-same\n(rewrite (Let v1 e (Lam v1 body)) (Lam v1 body))\n; let-lam-diff\n(rewrite (Let v1 e (Lam v2 body)) (Lam v2 (Let v1 e body))\n      :when ((!= v1 v2)\n             (= fvs (freer e))\n             (not-contains fvs v2)))\n(rule ((= expr (Let v1 e (Lam v2 body)))\n       (!= v1 v2)\n       (= fvs (freer e))\n       (contains fvs v2))\n      ((union expr (Lam (From expr) (Let v1 e (Let v2 (Var (From expr)) body))))))\n\n;; lambda_under\n(push)\n(define e \n        (Lam (V \"x\") \n             (Add (Val (Num 4))\n                  (App (Lam (V \"y\") (Var (V \"y\"))) (Val (Num 4))))))\n(run 10)\n(check (= e (Lam (V \"x\") (Val (Num 8)))))\n(pop)\n\n;; lambda_if_elim\n(push)\n(define e (If (Eq (Var (V \"a\")) (Var (V \"b\")))\n              (Add (Var (V \"a\")) (Var (V \"a\")))\n              (Add (Var (V \"a\")) (Var (V \"b\")))))\n(run 10)\n(check (= e (Add (Var (V \"a\")) (Var (V \"b\")))))\n(pop)\n\n;; lambda_let_simple\n(push)\n(define e (Let (V \"x\") (Val (Num 0))\n          (Let (V \"y\") (Val (Num 1))\n          (Add (Var (V \"x\")) (Var (V \"y\"))))))\n(run 10)\n(check (= e (Val (Num 1))))\n(pop)\n\n;; lambda_capture\n(push)\n(define e (Let (V \"x\") (Val (Num 1)) \n          (Lam (V \"x\") (Var (V \"x\")))))\n(run 10)\n(check (!= e (Lam (V \"x\") (Val (Num 1)))))\n(pop)\n\n;; lambda_capture_free\n(push)\n(define e  (Let (V \"y\") (Add (Var (V \"x\")) (Var (V \"x\"))) \n           (Lam (V \"x\") (Var (V \"y\")))))\n(run 10)\n(check (contains (freer (Lam (V \"x\") (Var (V \"y\")))) (V \"y\")))\n(check (!= e (Lam (V \"x\") (Add (Var (V \"x\")) (Var (V \"x\"))))))\n(pop)\n\n;; lambda_closure_not_seven\n(push)\n(define e\n     (Let (V \"five\") (Val (Num 5))\n     (Let (V \"add-five\") (Lam (V \"x\") (Add (Var (V \"x\")) (Var (V \"five\"))))\n     (Let (V \"five\") (Val (Num 6))\n     (App (Var (V \"add-five\")) (Val (Num 1)))))))\n(run 10)\n(check (!= e (Val (Num 7))))\n(check (= e (Val (Num 6))))\n(pop)\n\n;; lambda_compose\n(push)\n(define e\n    (Let (V \"compose\") (Lam (V \"f\") \n                       (Lam (V \"g\") \n                       (Lam (V \"x\") (App (Var (V \"f\"))\n                                         (App (Var (V \"g\")) \n                                              (Var (V \"x\")))))))\n    (Let (V \"add1\") (Lam (V \"y\") (Add (Var (V \"y\")) (Val (Num 1))))\n    (App (App (Var (V \"compose\")) (Var (V \"add1\"))) (Var (V \"add1\"))))))\n(run 20)\n(relation result ())\n(rule (\n    (= goal1 (Lam x (Add (Val (Num 1))\n                         (App (Lam y (Add (Val (Num 1)) (Var y)))\n                              (Var x)))))\n    (= goal2 (Lam x (Add (Var x) (Val (Num 2)))))\n)(\n    (result)\n))\n(run 1)\n(check (result))\n(pop)\n\n;; lambda_if_simple\n(push)\n(define e (If (Eq (Val (Num 1)) (Val (Num 1))) (Val (Num 7)) (Val (Num 9))))\n(run 4)\n(check (= e (Val (Num 7))))\n(pop)\n\n;; lambda_compose_many\n(push)\n(define e\n    (Let (V \"compose\") (Lam (V \"f\") (Lam (V \"g\") (Lam (V \"x\") (App (Var (V \"f\"))\n                                                              (App (Var (V \"g\")) (Var (V \"x\")))))))\n    (Let (V \"add1\") (Lam (V \"y\") (Add (Var (V \"y\")) (Val (Num 1))))\n    (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n         (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n              (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                   (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                        (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                             (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                                  (Var (V \"add1\")))))))))))\n\n(run 30)\n(relation result ())\n(rule (\n    (= e (Lam x (Add (Var x) (Val (Num 7)))))\n)(\n    (result)\n))\n(run 1)\n(check (result))\n(pop)\n\n;; lambda_if\n(push)\n(define e\n    (Let (V \"zeroone\") (Lam (V \"x\")\n         (If (Eq (Var (V \"x\")) (Val (Num 0)))\n             (Val (Num 0))\n             (Val (Num 1))))\n         (Add (App (Var (V \"zeroone\")) (Val (Num 0)))\n              (App (Var (V \"zeroone\")) (Val (Num 10)))))\n)\n(run 20)\n(check (= e (Val (Num 1))))\n(pop)\n",
  "map": "(sort MyMap (Map i64 String))\n\n(define my_map1 (insert (empty) 1 \"one\"))\n(define my_map2 (insert my_map1 2 \"two\"))\n\n(check (= \"one\" (get my_map1 1)))\n(extract my_map2)",
  "math": "(datatype Math\n    (Diff Math Math)\n    (Integral Math Math)\n    \n    (Add Math Math)\n    (Sub Math Math)\n    (Mul Math Math)\n    (Div Math Math)\n    (Pow Math Math)\n    (Ln Math)\n    (Sqrt Math)\n    \n    (Sin Math)\n    (Cos Math)\n    \n    (Const Rational)\n    (Var String))\n\n(relation MathU (Math))\n(rule ((= e (Diff x y))) ((MathU e)))\n(rule ((= e (Integral x y))) ((MathU e)))\n(rule ((= e (Add x y))) ((MathU e)))\n(rule ((= e (Sub x y))) ((MathU e)))\n(rule ((= e (Mul x y))) ((MathU e)))\n(rule ((= e (Div x y))) ((MathU e)))\n(rule ((= e (Pow x y))) ((MathU e)))\n(rule ((= e (Ln x))) ((MathU e)))\n(rule ((= e (Sqrt x))) ((MathU e)))\n(rule ((= e (Sin x))) ((MathU e)))\n(rule ((= e (Cos x))) ((MathU e)))\n(rule ((= e (Const x))) ((MathU e)))\n(rule ((= e (Var x))) ((MathU e)))\n\n(relation evals-to (Math Rational))\n\n(rule ((= e (Const c))) ((evals-to e c)))\n(rule ((= e (Add a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (+ va vb))))\n(rule ((= e (Sub a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (- va vb))))\n(rule ((= e (Mul a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (* va vb))))\n(rule ((= e (Div a b)) (evals-to a va) (evals-to b vb) (!= vb (rational 0 1)))\n      ((evals-to e (/ va vb))))\n(rule ((evals-to x vx)) ((union x (Const vx))))\n\n(relation is-const (Math))\n(rule ((evals-to a va)) ((is-const a)))\n\n(relation is-sym (Math))\n(rule ((= e (Var s))) ((is-sym e)))\n\n(relation is-not-zero (Math))\n(rule ((evals-to x vx)\n       (!= vx (rational 0 1)))\n      ((is-not-zero x)))\n\n(relation is-const-or-distinct-var-demand (Math Math))\n(relation is-const-or-distinct-var (Math Math))\n(rule ((is-const-or-distinct-var-demand v w)\n       (is-const v))\n      ((is-const-or-distinct-var v w)))\n(rule ((is-const-or-distinct-var-demand v w)\n       (= v (Var vv))\n       (= w (Var vw))\n       (!= vv vw))\n      ((is-const-or-distinct-var v w)))\n\n(rewrite (Add a b) (Add b a))\n(rewrite (Mul a b) (Mul b a))\n(rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))\n\n(rewrite (Sub a b) (Add a (Mul (Const (rational -1 1)) b)))\n(rewrite (Div a b) (Mul a (Pow b (Const (rational -1 1)))) :when ((is-not-zero b)))\n\n(rewrite (Add a (Const (rational 0 1))) a)\n(rewrite (Mul a (Const (rational 0 1))) (Const (rational 0 1)))\n(rewrite (Mul a (Const (rational 1 1))) a)\n\n;; NOTE: these two rules are different from math.rs, as math.rs does pruning\n(rule ((MathU a) (!= a (Const (rational 0 1)))) ((union a (Add a (Const (rational 0 1))))))\n(rule ((MathU a) (!= a (Const (rational 1 1)))) ((union a (Mul a (Const (rational 1 1))))))\n\n(rewrite (Sub a a) (Const (rational 0 1)))\n(rewrite (Div a a) (Const (rational 1 1)) :when ((is-not-zero a)))\n\n(rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))\n(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))\n\n(rewrite (Mul (Pow a b) (Pow a c)) (Pow a (Add b c)))\n(rewrite (Pow x (Const (rational 0 1))) (Const (rational 1 1)) :when ((is-not-zero x)))\n(rewrite (Pow x (Const (rational 1 1))) x)\n(rewrite (Pow x (Const (rational 2 1))) (Mul x x))\n(rewrite (Pow x (Const (rational -1 1))) (Div (Const (rational 1 1)) x) :when ((is-not-zero x)))\n(rewrite (Mul x (Div (Const (rational 1 1)) x)) (Const (rational 1 1)) :when ((is-not-zero x)))\n\n(rewrite (Diff x x) (Const (rational 1 1)) :when ((is-sym x)))\n(rule ((= e (Diff x c))\n       (is-sym x))\n      ((is-const-or-distinct-var-demand c x)))\n(rewrite (Diff x c) (Const (rational 0 1)) :when ((is-sym x) (is-const-or-distinct-var c x)))\n\n(rewrite (Diff x (Add a b)) (Add (Diff x a) (Diff x b)))\n(rewrite (Diff x (Mul a b)) (Add (Mul a (Diff x b)) (Mul b (Diff x a))))\n\n(rewrite (Diff x (Sin x)) (Cos x))\n(rewrite (Diff x (Cos x)) (Mul (Const (rational -1 1)) (Sin x)))\n\n(rewrite (Diff x (Ln x)) (Div (Const (rational 1 1)) x) :when ((is-not-zero x)))\n\n(rewrite (Diff x (Pow f g))\n         (Mul (Pow f g) \n              (Add (Mul (Diff x f) (Div g f)) \n                   (Mul (Diff x g) (Ln f)))) \n         :when ((is-not-zero f) \n                (is-not-zero g)))\n\n(rewrite (Integral (Const (rational 1 1)) x) x)\n(rewrite (Integral (Pow x c) x)\n         (Div (Pow x (Add c (Const (rational 1 1)))) (Add c (Const (rational 1 1)))) \n         :when ((is-const c)))\n(rewrite (Integral (Cos x) x) (Sin x))\n(rewrite (Integral (Sin x) x) (Mul (Const (rational -1 1)) (Cos x)))\n(rewrite (Integral (Add f g) x) (Add (Integral f x) (Integral g x)))\n(rewrite (Integral (Sub f g) x) (Sub (Integral f x) (Integral g x)))\n(rewrite (Integral (Mul a b) x) \n         (Sub (Mul a (Integral b x)) \n              (Integral (Mul (Diff x a) (Integral b x)) x)))\n\n;; math_simplify_root\n(push)\n(define start-expr\n    (Div (Const (rational 1 1))\n         (Sub (Div (Add (Const (rational 1 1))\n                        (Sqrt (Var \"five\")))\n                   (Const (rational 2 1)))\n              (Div (Sub (Const (rational 1 1))\n                        (Sqrt (Var \"five\")))\n                   (Const (rational 2 1))))))\n(run 11)\n(define end-expr\n    (Div (Const (rational 1 1))\n         (Sqrt (Var \"five\"))))\n(check (= start-expr end-expr))\n(pop)\n\n;; math_simplify_const\n(push)\n(define start-expr (Add (Const (rational 1 1))\n                        (Sub (Var \"a\") \n                             (Mul (Sub (Const (rational 2 1)) \n                                       (Const (rational 1 1))) \n                                  (Var \"a\")))))\n\n(run 6)\n\n(define end-expr (Const (rational 1 1)))\n(check (= start-expr end-expr))\n(pop)\n\n;; math_simplify_factor\n(push)\n(define start-expr (Mul (Add (Var \"x\") (Const (rational 3 1)))\n                        (Add (Var \"x\") (Const (rational 1 1)))))\n(run 8)\n(define end-expr (Add (Add (Mul (Var \"x\") (Var \"x\"))\n                           (Mul (Const (rational 4 1)) (Var \"x\")))\n                           (Const (rational 3 1))))\n(check (= start-expr end-expr))\n(pop)\n",
  "name-resolution": "(datatype Math\n  (Add Math Math)\n  (Num i64))\n  \n(define zero (Num 0))\n\n\n;; zero here refers to the function/constant zero, not a free variable\n(rewrite (Add zero x) x)\n\n(define a (Add (Num 0) (Num 3)))\n(define b (Add (Num 7) (Num 9)))\n(define c (Num 16))\n(union b c)\n\n;; crash if we merge two numbers\n(rule (\n (= (Num x) (Num y))\n (!= x y)\n)(\n (panic \"ahhh\")\n))\n      \n      \n(run 10)",
  "path-union": "(datatype Node\n (mk i64))\n\n(relation edge (Node Node))\n(relation path (Node Node))\n            \n(rule ((edge x y))\n      ((path x y)))\n\n(rule ((path x y) (edge y z))\n      ((path x z)))\n\n(edge (mk 1) (mk 2))\n(edge (mk 2) (mk 3))\n(edge (mk 5) (mk 6))\n\n(union (mk 3) (mk 5))\n\n(run 10)\n(check (edge (mk 3) (mk 6)))\n(check (path (mk 1) (mk 6)))",
  "path": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(rule ((path x y) (edge y z))\n      ((path x z)))\n        \n(edge 1 2)\n(edge 2 3)\n(edge 3 4)\n(check (edge 1 2))\n(run 3)\n\n(print path)\n(check (path 1 4))\n",
  "pathproof": "; proofs of connectivity are paths\n(datatype Proof\n  (Trans i64 Proof)\n  (Edge i64 i64))\n\n; We enhance the path relation to carry a proof field\n(relation path (i64 i64 Proof))\n(relation edge (i64 i64))\n\n(edge 2 1)\n(edge 3 2)\n(edge 1 3)\n\n(rule ((edge x y))  \n      ((path x y (Edge x y))))\n(rule ((edge x y) (path y z p))  \n      ((path x z (Trans x p))))\n\n; We consider equal all paths tha connect same points.\n; Smallest Extraction will extract shortest path.\n(rule ((path x y p1) (path x y p2))  \n      ((union p1 p2)))\n\n(run 3)\n(check (path 3 1 (Trans 3 (Edge 2 1))))\n; Would prefer being able to check\n;(check (path 1 2 _))\n; or extract\n;(extract (path 1 4 ?p))\n(print path)",
  "points-to": "; Identifiers represented as strings, keep some newtypes around to aid clarity\n(datatype Class (Class String))\n(datatype Field (Field String))\n\n(datatype Stmt\n    (New String Class)\n    ; Assign dst src\n    (Assign String String)\n    ; Store dst field src\n    (Store String Field String)\n    ; Load dst src field\n    (Load String String Field))\n\n(relation VarPointsTo (String Class))\n(relation HeapPointsTo (Class Field Class))\n\n; New variables point to classes they're initialized as\n(rule ((= x (New a b))) ((VarPointsTo a b)))\n\n; If I assign v1 <- v2 and v2 points to a class c2, then v1 points to class c2\n; as well\n(rule ((= x (Assign v1 v2)) (VarPointsTo v2 c2))\n      ((VarPointsTo v1 c2)))\n\n; If c1.f points to c2, and v2 points to class c1, then assigning v1 <- v2.f\n; means v1 points to c2\n(rule ((= x (Load v1 v2 f)) \n       (VarPointsTo v2 c1)\n       (HeapPointsTo c1 f c2))\n      ((VarPointsTo v1 c2)))\n\n; If v1 points to class c1, and v2 to c2, and if v1.f <- v2, then c1.f points to\n; c2\n(rule ((= x (Store v1 f v2))\n       (VarPointsTo v1 c1)\n       (VarPointsTo v2 c2))\n      ((HeapPointsTo c1 f c2)))\n\n; Example in \"From Datalog to Flix\"\n; l1: ClassA o1 = new ClassA();\n; l2: ClassB o2 = new ClassB();\n; l3: ClassB o3 = o2;\n; l4: o2.f = o1;\n; l5: Object r = o3.f;\n\n(define A (Class \"A\"))\n(define B (Class \"B\"))\n(define f (Field \"f\"))\n\n(define l1 (New \"o1\" A))\n(define l2 (New \"o2\" B))\n(define l3 (Assign \"o3\" \"o2\"))\n(define l4 (Store \"o2\" f \"o1\"))\n(define l5 (Load \"r\" \"o3\" f))\n\n(run 3)\n\n(check (VarPointsTo \"o1\" A))\n(check (VarPointsTo \"o2\" B))\n\n(check (VarPointsTo \"o3\" B))\n(check (HeapPointsTo B f A))\n(check (VarPointsTo \"r\" A))",
  "primitives": "(check (= (+ 2 2)  4))\n(check (= (- 2 1)  1))\n(check (= (- 1 2) -1))\n(check (< 1 2))\n(check (> 1 -2))",
  "push-pop": "(function foo () i64 :merge (max old new))\n\n(set (foo) 1)\n(check (= (foo) 1))\n\n(push)\n(set (foo) 2)\n(check (= (foo) 2))\n(pop)\n\n(check (= (foo) 1))",
  "rw-analysis": ";;;;;;;;;;;;;;;;\n;; Abstact Domain\n;;;;;;;;;;;;;;;;\n\n; Top means it can be an arbitrary value\n(datatype Val (Top) (I i64) (True) (False))\n(relation Bool (Val))\n(Bool (True))\n(Bool (False))\n\n(function merge-val (Val Val) Val)\n\n(rewrite (merge-val (Top) x) (Top))\n(rewrite (merge-val x (Top)) (Top))\n(rewrite (merge-val (True)  (False)) (Top))\n(rewrite (merge-val (True)  (I x))   (Top))\n(rewrite (merge-val (False) (True))  (Top))\n(rewrite (merge-val (False) (I x))   (Top))\n(rewrite (merge-val (I x) (I y)) (Top) :when ((!= x y)))\n(rewrite (merge-val x x) x)\n\n(function add-val (Val Val) Val)\n\n(rewrite (add-val (Top) x) (Top))\n(rewrite (add-val x (Top)) (Top))\n(rewrite (add-val (True) x) (Top))\n(rewrite (add-val (False) x) (Top))\n(rewrite (add-val x (True)) (Top))\n(rewrite (add-val x (False)) (Top))\n(rewrite (add-val (I x) (I y)) (I (+ x y)))\n\n(function eq-val (Val Val) Val)\n\n(rewrite (eq-val (Top) x) (Top))\n(rewrite (eq-val x (Top)) (Top))\n(rewrite (eq-val (True) (False)) (False))\n(rewrite (eq-val (True) (I x)) (False))\n(rewrite (eq-val (False) (True)) (False))\n(rewrite (eq-val (False) (I x)) (False))\n(rewrite (eq-val (I x) (True)) (False))\n(rewrite (eq-val (I x) (False)) (False))\n(rewrite (eq-val x x) (True))\n\n(datatype Var (V String))\n(datatype Loc (L i64))\n(datatype Exp\n    (Add Var Var)\n    (Eq Var Var)\n    (Var Var)\n    (Const Val))\n(datatype ProgStmt\n    (Ass Var Exp)\n    (If Var Loc Loc)\n    (Goto Loc)\n    (Call Var)\n    (End))\n(function Prog (Loc) ProgStmt)\n(relation RProg (Loc ProgStmt))\n\n(function const-prop (Loc Var) Val :merge (merge-val old new))\n\n;;;;;;;;;;;;;;;;\n;; ASS Case\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n\n; propagate x = k\n(rule (\n    (RProg (L li) (Ass x (Const k)))\n)(\n    (set (const-prop (L (+ li 1)) x) k)\n))\n\n; propagate x = a + b (non-constant)\n(rule (\n    (RProg l (Ass x (Add x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) (add-val v1 v2))\n))\n\n; propagate x = a == b\n(rule (\n    (RProg l (Ass x (Eq x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) (eq-val v1 v2))\n))\n\n; propagate other vars\n(rule (\n    (RProg (L li) (Ass (V x) e))\n    (= val (const-prop (L li) (V y)))\n    (!= x y)\n)(\n    (set (const-prop (L (+ li 1)) (V y)) val)\n))\n\n;; TRANSFORMATION \n\n; generate demand for biop\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n)(\n    (add-val v1 v2)\n))\n\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n)(\n    (eq-val v1 v2)\n))\n\n; replace x = a + b (constant)\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= (I val) (add-val (const-prop l x1)\n                        (const-prop l x2)))\n)(\n    (RProg l (Ass x (Const (I val))))\n))\n\n; replace x = a + b (non-contant)\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= (Top) (add-val (const-prop l x1)\n                      (const-prop l x2)))\n)(\n    (RProg l (Ass x (Add x1 x2)))\n))\n\n; replace x = a == b (constant)\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= b (eq-val (const-prop l x1) (const-prop l x2)))\n    (Bool b)\n)(\n    (RProg l (Ass x (Const b)))\n))\n\n; replace x = a == b (non-constant)\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= (Top) (eq-val (const-prop l x1) (const-prop l x2)))\n)(\n    (RProg l (Ass x (Eq x1 x2)))\n))\n\n; replace x = k\n(rule (\n    (= (Prog l) (Ass x (Const val)))\n)(\n    (RProg l (Ass x (Const val)))\n))\n\n;;;;;;;;;;;;;;;;\n;; CALL CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l (Call f))\n    (= val (const-prop l x))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) val)\n))\n\n;; TRANSFORMATION\n(rule (\n    (= (Prog l) (Call f))\n)(\n    (RProg l (Call f))\n))\n\n;;;;;;;;;;;;;;;;\n;; IF CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l (If b l1 l2))\n    (= val (const-prop l x))\n)(\n    (set (const-prop l1 x) val)\n    (set (const-prop l2 x) val)\n))\n\n;; TRANSFORMATION\n\n; replace if true\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= (True) (const-prop l b))\n)(\n    (RProg l (Goto l1))\n))\n\n; replace if false\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= (False) (const-prop l b))\n)(\n    (RProg l (Goto l2))\n))\n\n; replace if Top\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= (Top) (const-prop l b))\n)(\n    (RProg l (If b l1 l2))\n))\n\n;;;;;;;;;;;;;;;;\n;; GOTO CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l1 (Goto l2))\n    (= val (const-prop l1 x))\n)(\n    (set (const-prop l2 x) val)\n))\n\n;; TRANSFORMATION\n(rule (\n    (= (Prog l1) (Goto l2))\n)(\n    (RProg l1 (Goto l2))\n))\n\n;;;;;;;;;;;;;;;;\n;; TEST\n;;;;;;;;;;;;;;;;\n\n(union (Prog (L 0)) (Ass (V \"b\") (Const (Top))))\n(union (Prog (L 1)) (Ass (V \"ten\") (Const (I 10))))\n(union (Prog (L 2)) (Ass (V \"one\") (Const (I 1))))\n(union (Prog (L 3)) (Ass (V \"zero\") (Const (I 0))))\n; x := 10\n(union (Prog (L 4)) (Ass (V \"x\") (Const (I 10))))\n; while (...) {\n(union (Prog (L 5)) (If (V \"b\") (L 6) (L 13)))\n;     if (x == 10) {\n(union (Prog (L 6)) (Ass (V \"cond\") (Eq (V \"x\") (V \"ten\"))))\n(union (Prog (L 7)) (If (V \"cond\") (L 8) (L 10)))\n;         DoSomething();\n(union (Prog (L 8)) (Call (V \"DoSomething\")))\n;     }\n(union (Prog (L 9)) (Goto (L 12)))\n;     else {\n;         DoSomething();\n(union (Prog (L 10)) (Call (V \"DoSomethingElse\")))\n;         x := x + 1;\n(union (Prog (L 11)) (Ass (V \"x\") (Add (V \"x\") (V \"one\"))))\n;; (union (Prog (L 11)) (Call (V \"DoSomethingElse\")))\n;     }\n(union (Prog (L 12)) (Goto (L 5)))\n; y := x\n(union (Prog (L 13)) (Ass (V \"y\") (Add (V \"x\") (V \"zero\"))))\n(union (Prog (L 14)) (End))\n\n(run 20)\n\n(check (= (const-prop (L 14) (V \"y\")) (I 10)))\n\n",
  "stratified": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(edge 1 2)\n(edge 2 3)\n(edge 3 4)\n(check (edge 1 2))\n(run 3)\n(check (path 1 2))\n\n(clear-rules)\n(rule ((path x y) (edge y z))\n      ((path x z)))\n\n(edge 3 8)\n(run 1)\n(check (path 1 3))\n\n\n\n; Should fail\n; (check (path 1 4))\n; (check (path 3 8)) \n",
  "typecheck": "; type checking for simply typed lambda calculus\n\n(datatype Type \n  (TUnit) \n  (TArr Type Type) ; t1 -> t2\n)\n\n(datatype Expr \n  (Lam String Type Expr) ; lam x : t . e\n  (App Expr Expr) \n  (Var String) \n  (Unit)\n)\n\n(datatype Ctx \n  (Nil) \n  (Cons String Type Ctx)\n)\n\n; ctx |- expr : type\n(function typeof (Ctx Expr) Type)\n\n; ctx |- () : unit\n(rewrite (typeof ctx (Unit)) (TUnit))\n\n; ctx; x: t |- x : t\n(rewrite (typeof (Cons x t ctx) (Var x)) t)\n\n; ctx |- f :- t1 -> t2\n; ctx |- e : t1\n; -----------------\n; ctx |- f e : t2\n\n(rule (\n  (= (typeof ctx (App f e)) t2)\n)(\n  (typeof ctx f)\n  (typeof ctx e)\n))\n\n(rule (\n  (= (typeof ctx (App f e)) t1)\n  (= (typeof ctx f) (TArr (typeof ctx e) t2))\n)(\n  (union t1 t2)\n))\n\n; ctx |- x : t\n; ------------------ y != x \n; ctx; y: t |- x : t\n\n(rewrite (typeof (Cons y ty ctx) (Var x))\n         (typeof ctx (Var x))\n    :when ((!= x y)))\n\n; ctx; x: t1 |- e : t2\n; ------------------------------\n; ctx |- lam x: t1. e : t1 -> t2\n\n; rhs of rewrite creates demand\n(rewrite (typeof ctx (Lam x t1 e))\n         (TArr t1 (typeof (Cons x t1 ctx) e)))\n\n; TEST\n; ----\n\n; lam x : unit, f : unit -> unit . f x\n(define e \n  (Lam \"x\" (TUnit) \n       (Lam \"f\" (TArr (TUnit) (TUnit))\n            (App (Var \"f\") (Var \"x\")))))\n\n; lam x : unit . x\n(define id (Lam \"x\" (TUnit) (Var \"x\")))\n(define t-id (typeof (Nil) id))\n\n; (e () id) = ()\n(define app-unit-id (App (App e (Unit)) id))\n(define t-app (typeof (Nil) app-unit-id))\n\n(define free (Lam \"x\" (TUnit) (Var \"y\")))\n(define t-free-ill (typeof (Nil) free))\n(define t-free-1 (typeof (Cons \"y\" (TUnit) (Nil)) free))\n(define t-free-2 (typeof (Cons \"y\" (TArr (TArr (TUnit) (TUnit)) (TUnit)) (Nil)) free))\n\n(run 15)\n\n(extract t-id)\n(check (= t-id (TArr (TUnit) (TUnit))))\n\n(extract t-app)\n(check (= t-app (TUnit)))\n\n(extract t-free-1)\n(check (= t-free-1 (TArr (TUnit) (TUnit))))\n(extract t-free-2)\n(check (= t-free-2 (TArr (TUnit) (TArr (TArr (TUnit) (TUnit)) (TUnit)))))\n; this will err\n; (extract t-free-ill)\n",
  "typeinfer": ";;;;;;;;;;;;;;;;;;;;;;\n;; Exprs and Types\n;;;;;;;;;;;;;;;;;;;;;;\n\n(datatype Ident)\n(datatype Expr)\n(datatype Type)\n(datatype Scheme)\n(datatype Ctx)\n;; TODO: can't do unit right now\n;; (sort QuantifiedVs (Map String Unit))\n(sort QuantifiedVs (Map Ident i64))\n\n(function FreshFromSubst (QuantifiedVs Ident) Ident)\n(function FreshFromLam (Ctx Ident Expr) Ident)\n(function V (String) Ident)\n\n(function Var (Ident) Expr)\n(function App (Expr Expr) Expr)\n(function Abs (Ident Expr) Expr)\n(function Let (Ident Expr Expr) Expr)\n(function Num (i64) Expr)\n(function True () Expr)\n(function False () Expr)\n(function Unit () Expr)\n\n(function TVar (Ident) Type)\n(function TArr (Type Type) Type)\n(function TInt () Type)\n(function TBool () Type)\n(function TUnit () Type)\n\n(function Forall (QuantifiedVs Type) Scheme)\n(function Nil () Ctx)\n(function Cons (Ident Scheme Ctx) Ctx)\n\n(relation keySet (Ctx QuantifiedVs))\n(relation has-qs (Ctx Type QuantifiedVs))\n(relation has-qs-demand (Ctx Type))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Scheme and Context\n;;;;;;;;;;;;;;;;;;;;;;\n\n(rule ((= c (Nil))) ((keySet c (empty))))\n(rule ((= c (Cons x s n))\n       (keySet n fvs))\n      ((keySet c (insert fvs x 1))))\n\n;; TODO: rewrite lookup to use native sets\n(function lookup (Ctx Ident) Scheme)\n(rewrite (lookup (Cons x s tl) x) s)\n(rule (\n  (= t (lookup (Cons y s tl) x))\n  (!= x y)\n)(\n  (union t (lookup tl x))\n))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Generalization and Instantiation\n;;;;;;;;;;;;;;;;;;;;;;\n\n(function generalize (Ctx Type) Scheme)\n(function instantiate (Scheme) Type)\n\n(rule ((has-qs-demand ctx (TInt)))\n      ((has-qs ctx (TInt) (empty))))\n(rule ((has-qs-demand ctx (TBool)))\n      ((has-qs ctx (TBool) (empty))))\n(rule ((has-qs-demand ctx (TUnit)))\n      ((has-qs ctx (TUnit) (empty))))\n\n(rule ((has-qs-demand ctx (TArr fr to)))\n      ((has-qs-demand ctx fr)\n       (has-qs-demand ctx to)))\n(rule ((has-qs-demand ctx (TArr fr to))\n       (has-qs ctx fr qs1)\n       (has-qs ctx to qs2))\n      ((has-qs ctx (TArr fr to) (set-union qs1 qs2))))\n\n(rule ((has-qs-demand ctx (TVar x))\n       (keySet ctx key-set)\n       (= unused (get key-set x)))\n      ((has-qs ctx (TVar x) (empty))))\n(rule ((has-qs-demand ctx (TVar x))\n       (keySet ctx key-set)\n       (not-contains key-set x))\n      ((has-qs ctx (TVar x) (insert (empty) x 1))))\n\n(rule ((= sc (generalize ctx t)))\n      ((has-qs-demand ctx t)))\n(rewrite (generalize ctx t)\n         (Forall qs t)\n         :when ((has-qs ctx t qs)))\n\n(function subst-fresh (QuantifiedVs Type) Type)\n\n(rewrite (subst-fresh vs (TInt)) (TInt))\n(rewrite (subst-fresh vs (TBool)) (TBool))\n(rewrite (subst-fresh vs (TUnit)) (TUnit))\n(rewrite (subst-fresh vs (TArr fr to)) \n         (TArr (subst-fresh vs fr) (subst-fresh vs to)))\n(rule ((= otype (subst-fresh vs (TVar s)))\n       (= unused (get vs s)))\n      ((union otype (TVar (FreshFromSubst vs s)))))\n(rule ((= otype (subst-fresh vs (TVar s)))\n       (not-contains vs s))\n      ((union otype (TVar s))))\n\n(rewrite (instantiate (Forall vs t))\n         (subst-fresh vs t))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Injectivity\n;;;;;;;;;;;;;;;;;;;;;;\n\n(rule ((= (TArr fr1 to1) (TArr fr2 to2)))\n      ((union fr1 fr2) \n       (union to1 to2)))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Type inference\n;;;;;;;;;;;;;;;;;;;;;;\n\n; ctx |- expr : type\n(function typeof (Ctx Expr) Type)\n\n;; Basic types (TInt, TBool, TUnit)\n(rewrite (typeof ctx (Num x)) (TInt))\n(rewrite (typeof ctx (True)) (TBool))\n(rewrite (typeof ctx (False)) (TBool))\n(rewrite (typeof ctx (Unit)) (TUnit))\n\n; sc = lookup(ctx, x)\n; t = instantiate(sc)\n; ---------------\n; ctx |- x : t\n(rewrite (typeof ctx (Var x))\n         (instantiate (lookup ctx x)))\n\n(rewrite \n  (typeof ctx (Abs x e))\n  (TArr (TVar (FreshFromLam ctx x e)) \n        (typeof (Cons x (Forall (empty) (TVar (FreshFromLam ctx x e)))\n                      ctx) \n                e)))\n\n(rule ((= to (typeof ctx (App e1 e2))))\n      ((union (typeof ctx e1) \n              (TArr (typeof ctx e2) to))))\n\n(rewrite (typeof ctx (Let x e1 e2))\n         (typeof (Cons x (generalize ctx (typeof ctx e1)) \n                       ctx)\n                 e2))\n\n(define id (Abs (V \"x\") (Var (V \"x\"))))\n(define t-id (typeof (Nil) id))\n\n(define let-poly (Let (V \"id\") (Abs (V \"x\") (Var (V \"x\")))\n                  (App (App (Var (V \"id\")) (Var (V \"id\")))\n                       (App (Var (V \"id\")) (True)))))\n(define t-let-poly (typeof (Nil) let-poly))\n\n(run 20)\n\n(check (= t-id (TArr (TVar (FreshFromLam (Nil) (V \"x\") (Var (V \"x\"))))\n                     (TVar (FreshFromLam (Nil) (V \"x\") (Var (V \"x\")))))))\n(check (= t-let-poly (TBool)))\n",
  "unify": "(datatype Expr\n  (Mul Expr Expr)\n  (Var String)\n  (Lit i64)\n)\n\n; Assume injectivity of Mul for unification\n(rule ((= (Mul a b) (Mul c d)))\n      ((union a c)\n       (union b d)))\n\n;; (relation False (i64))\n; If any Literal make equal to something it can't be, false is derived\n;(rule ((= (Lit i) (Lit j)) (!= i j))\n;      ((False 0)))\n(rule ((= (Lit i) (Mul a b)))\n      ((panic \"Literal cannot be equal to a product\")))\n\n(set (Mul (Var \"a\") (Var \"a\")) \n     (Mul (Lit 1) (Lit 2)))\n\n\n(run 3)\n(check (= (Var \"a\") (Lit 1)))\n(check (= (Lit 2) (Lit 1)))\n; (check (False 0)) ;; this should fail because we don't want prove false"
}
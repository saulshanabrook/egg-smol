(datatype Math
  (Num i64)
  (Var String)
  (Add Math Math)
  (Mul Math Math))

(rewrite (Mul (Num x) (Num y)) (Num (* x y)))
(rewrite (Add (Num x) (Num y)) (Num (+ x y)))

(datatype MathList
  (Nil)
  (Cons Math MathList))

(sort MathFn (Fn (Math) Math))


; (function square (Math) Math)
; (rewrite (square x) (Mul x x))

; (let square-fn (fn "square" ))

; ;; test that we can call a function
; (let squared-3 (app square-fn (Num 3)))
; (check (= squared-3 (square (Num 3))))

; ;; test that we can apply a function to a list

; (function list-map-math (MathList MathFn) MathList)
; (rewrite (list-map-math (Nil) fn) (Nil))
; (rewrite (list-map-math (Cons x xs) fn) (Cons (app fn x) (list-map-math xs fn)))

; (let x (Cons (Num 1) (Cons (Num 2) (Cons (Num 3) (Nil)))))
; (let squared-x (list-map-math x square-fn))
; (run 100)
; (check (= squared-x (Cons (Num 1) (Cons (Num 4) (Cons (Num 9) (Nil))))))

; ;; Test that we can partially apply a function in a rewrite rule

; (function list-multiply-by (MathList Math) MathList)
; (rewrite (list-multiply-by l i) (list-map-math l (fn "Mul" i)))

; (let doubled-x (list-multiply-by x (Num 2)))
; (run 100)
; (check (= doubled-x (Cons (Num 2) (Cons (Num 4) (Cons (Num 6) (Nil))))))

; ;; Test we can define a higher order compose function

; (function composed-math (MathFn MathFn Math) Math)
; (rewrite (composed-math f g v) (app f (app g v)))

; (let square-of-double (fn "composed-math" square-fn (fn "Mul" (Num 2))))

; (let squared-doubled-x (list-map-math x square-of-double))
; (run 100)
; (check (= squared-doubled-x (Cons (Num 4) (Cons (Num 16) (Cons (Num 36) (Nil))))))


; ;; See that it supports primitive values as well
; (sort i64Fun (Fn (i64) i64))

; (function composed-i64-math (MathFn i64Fun i64) Math)
; (rewrite (composed-i64-math f g v) (app f (Num (app g v))))

; (let res (composed-i64-math square-fn (fn "*" 2) 4))
; (run 100)
; (check (= res (Num 64)))

;; Let's try implementing a fixpoint function and use it to define fibonacci
; (ruleset fix-ruleset)
; (sort MathFnHigher (Fn (MathFn) MathFn))
; (function fix (MathFnHigher) MathFnHigher :ruleset fix-ruleset)
; (rewrite (fix f) (f (fix f)))

(datatype Bool
  (True)
  (False))

(function math-= (Math Math) Bool)
(rewrite (math-= x x) (True))
(rewrite (math-= (Num i) (Num j)) (False) :when ((!= i j)))

(function if (Bool Math Math) Math)
(rewrite (if (True) x y) x)
(rewrite (if (False) x y) y)

(ruleset fib-ruleset)
(function fib (Math) Math)
(rewrite (fib i)
  (if (math-= i (Num 0))
      (Num 0)
      (if (math-= i (Num 1))
          (Num 1)
          (Add (fib (Add i (Num -1)))
               (fib (Add i (Num -2))))))
  :ruleset fib-ruleset)

(let y (fib (Num 7)))

;; Run the fib ruleset 4 times,
(run-schedule (repeat 7 (saturate (run)) (run fib-ruleset) (saturate (run))))
(extract y)
; (rewrite (fib (x)))

(datatype Math
  (Num Rational)
  (Var String)
  (Add Math Math)
  (Div Math Math))

(let zero (Num (rational 0 1)))
(let one (Num (rational 1 1)))
(let two (Num (rational 2 1)))
(Add one two)

(rewrite (Add ?a ?b) (Add ?b ?a))

;; run all of our rules, once
(run 1)

(rewrite (Add (Num ?r1) (Num ?r2))
         ;; primitive plus!
         (Num [+ ?r1 ?r2]))

(run 1)

;; run a query that 1+2=3
(check (= (Add one two)
          (Num (rational 3 1))))
;; run a query that 2+1=1+2
(check (= (Add two one)
          (Add one two)))


(rewrite (Add ?a zero) ?a)

;; `rewrite` is sugar for:
(rule (
  (Add ?a zero)
)(
  (union (Add ?a zero) ?a)
))


(push)


;; a more complex action:
(rule (
  (Num ?r)
)(
  (union one
        (Div (Num ?r) (Num ?r)))
))


(run 1)

;; uh oh, division by zero!
(check (Div zero zero))
(pop)


;; one lower-bound per e-class
(function lower-bound (Math) Rational
          :merge (max old new))
;; one upper-bound per e-class
(function upper-bound (Math) Rational
          :merge (min old new))

;; Set the bounds for constants
(rule ((Num ?r))
      ((set (lower-bound (Num ?r)) ?r)
       (set (upper-bound (Num ?r)) ?r)))

;; Propagate lower-bound for addition
(rule ((Add ?a ?b))
      ((set (lower-bound (Add ?a ?b))
            (+ (lower-bound ?a)
               (lower-bound ?b)))))

;; Propagate upper-bound for addition
(rule ((Add ?a ?b))
      ((set (upper-bound (Add ?a ?b))
            (+ (upper-bound ?a)
               (upper-bound ?b)))))


(let x (Var "x"))
(let x1 (Add x one))

(set (lower-bound x) (rational 0 1))
(set (upper-bound x) (rational 1 1))

(run 2)

(extract (lower-bound x1))
(extract (upper-bound x1))



(rule (
  (= ?expr (Num ?a))
  ;; filter using primitive >
  [> (lower-bound ?expr)
     (rational 0 1)]
)(
  (union one
         (Div ?expr
              ?expr))
))

;; same rule as above, but for addition
(rule (
  (= ?expr (Add ?a ?b))
  ;; filter using primitive >
  [> (lower-bound ?expr)
     (rational 0 1)]
)(
  (union one
         (Div ?expr
              ?expr))
))

(run 1)

(check (= one (Div ?x1 ?x1)))


;; Set the variable x to a particular input value 200/201
(set (lower-bound x) (rational 200 201))
(set (upper-bound x) (rational 200 201))

(run 3)

;; We have found tight bounds on the output!
(extract (lower-bound x1))
(extract (upper-bound x1))


(function true-value (Math) f64)

(rule ((= (to-f64 (lower-bound e))
          (to-f64 (upper-bound e))))
      ((set (true-value e)
            (to-f64 (lower-bound e)))))

(run 1)
(extract (true-value x1))

(function best-error (Math) f64
          :merge new :default (to-f64 (rational 10000 1)))

(rule ((Num n))
      ((set (best-error (Num n)) (to-f64 n))))
(rule ((Add a b)) ((best-error (Add a b))))

;; finally, the mega rule for finding
;; more accurate programs
(rule ((= expr (Add a b))
       (= (best-error a) va)
       (= (best-error b) vb)
       (= true-v (true-value (Add a b)))
       (= computed (+ va vb))
       (< (abs (- computed true-v))
          (best-error (Add a b))))
      ((set (best-error (Add a b)) computed)))



(push)

(let target
  (Add 
    (Add (Num (rational 1 100)) (Num (rational 1 100)))
    (Num (rational -2 100))))

(run 1)

;; error is bad, constant folding
;; hasn't fired enough
(extract (best-error target))

(run 1)

;; error is good
;; constant folding has fired enough
(extract (best-error target))


(pop)